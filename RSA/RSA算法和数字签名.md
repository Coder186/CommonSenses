# RSA算法和数字签名

## 需求
如果我收到这样一个需求：我通过网络发送一些数据给某些人，接收到数据的人需要验证这些数据在传输途中没有被篡改，且的确是我发送的。该如何去实现呢？

## 方案
用RSA加密算法来对要传输的数据做一份数字签名，同时公布RSA的公钥，让接收人用公钥来验证数字签名。

## RSA
RSA加密算法是非对称加密算法。如果加密解密用的密钥是同一个那是对称加密算法。而加密和解密所用的密钥是不同的那就是非对称加密算法。

## 公钥和私钥
非对称加密算法的密钥有私钥，公钥两种。（Private Key，Public Key）  
公开给别人，不怕泄漏的是公钥。  
私人保管，不能泄漏的是私钥。一旦私钥泄漏，就意味着密文可以被解密，唯一身份会被盗用。  
加密明文的可以是私钥，也可以是公钥。  
无论用公钥或者私钥来加密，都不能再用相同的密钥来解密，必须要用公私相异的另外一种来解密。

## 加密传输数据的场景
1. 发送者用公开的公钥对一段数据进行加密
2. 发送密文给接收者
3. 接收者收到密文后用私钥进行解密  

由于私钥保密，所以只有私钥持有人才能解开密文，这样传输过程中不用担心数据被篡改，被偷窥。  
在这种场景下，公钥是用来加密数据的，而私钥是用来解密数据的。

## 数字签名的场景
1. 发送者用私钥对数据进行加密
2. 发送者把明文和密文同时发送出去
3. 接收者接收到了明文和密文后用公钥对密文做解密
4. 接收者比较收到的明文和解密后的明文，如何两者一致，就表明这段数据的发送者就是私钥的持有人。  

由于明文、密文同时发送，明文是可以被别人查看的。  
数据在传输过程如果被篡改，会造成明文数据无法和解密的数据保持一致，可以识别出数据是否在传输过程中被篡改。  
在这种场景下，私钥是用来加密数据的，而公钥是用来解密数据的。

## RS256算法
真实世界的数字签名生成和上面提到的流程略有不同。  
由于对明文做RSA加密运算相对比较费时费力。但需求是对数据做签名，而不是加密传输。可以不用对整个明文数据做RSA加密，而先对明文做一次SHA256运算。SHA256可以保证相同输入输出一一对应，且输出的数据只有256个Bit。再对这个256个Bit的数据做RSA加密就会轻松很多。这样，RSA + SHA256 = RS256算法。  
  
新的数字签名流程是：
1. 发送者用SHA256算法计算出明文哈希值
2. 发送者用私钥和RSA算法对哈希值加密，得到的结果就是数字签名
3. 发送者把明文和数字签名一起发送
4. 接收者接收到了明文和数字签名后用公钥对数字签名做解密，得到的是解密后的SHA256的值
5. 接收者对明文做一次SHA256运算
6. 接收者对比两个SHA256值是否相同。如果相同，那就说明这段数据是私钥持有者发送的，且没有被篡改  

## 总结
加密：明文--公钥加密---密文--私钥解密---明文  
签名：明文的哈希--私钥加密---签名---公钥解密----明文的哈希

